<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <div style="text-align: right"><a href="{{ url_for('rebind_otp') }}" style="text-align: right">Rebind OTP</a></div>
    <h2>Chat Application <small> - (<a href="{{ url_for('logout') }}">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <input type="hidden" name="csrf_token" value = "{{ csrf_token() }}" />
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <!-- <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button> -->
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;
let myExportPublicKey_time;
let lastMessage;
let last_finished;
var csrf_token = "{{ csrf_token() }}";


var decryption_iv_me_to_peer;
var decryption_iv_peer_to_me;
let s_secret;
let c_keyset;
let older;
// let first = 0;

$.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("X-CSRFToken", csrf_token);
            }
        }
    });

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
    // myExportPublicKey == null;
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}

function sendEraseChat(){
  sendMessage("erase chat");
}

// Send message function
async function sendMessage(type) {
  if (localStorage.getItem("USER"+peer_id.toString())==null && (type=='normal' || type=='refresh key')){
    window.alert("no key materials, please wait for seconds for ECDH exchange");
    return;
  }
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal' ) {
        secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
        counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
        
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());

        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
      secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signpreiv(counter, secret_counter,"change");
        // put the old mac signed iv into msg_value
        value = await signiv(counter-1, secret_counter, "change");
    }
    if (type=='erase chat'){
        message = "";
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
    };
    console.log("the message I sent",JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrf_token,
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users', {
        method: "GET",
        headers: {
            'X-CSRFToken': csrf_token,
        }
    })
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));

});

// Handle user selection change
document.getElementById('userList').addEventListener('change', async(event) => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    older = true;
    // first = 0;
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      decryption_iv_me_to_peer = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString()));
      decryption_iv_peer_to_me = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString()));
      s_secret = JSON.parse(localStorage.getItem("secret_START_USER"+peer_id.toString()));
      c_keyset = JSON.parse(localStorage.getItem("keyset_START_USER"+peer_id.toString()));
    }
    await fetchMessages(); // Fetch messages for the new selection

    if (localStorage.getItem("USER"+peer_id.toString())==null && myID<peer_id){
      await initial_ECDH();
      setInterval(fetchMessages, 2000);
      delay();
    }
    else if (localStorage.getItem("USER"+peer_id.toString())==null && myID>peer_id){
      // wait for 2 seconds to catch init if there is
      await new Promise(resolve => setTimeout(resolve, 2000));
      await fetchMessages();
      setInterval(fetchMessages, 2000);
      setInterval(checklocalStorage, 65000);
    }else {
      setInterval(fetchMessages, 2000);
      setInterval(checklocalStorage, 65000);

    }
    // setInterval(fetchMessages, 1000);
    
});

function delay(){
  // a key exchange message is valid for 1min
  setInterval(checklocalStorage, 65000);
}

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

function checklocalStorage(){
  console.log("checklocalStorage");
  if (localStorage.getItem("USER"+peer_id.toString())==null){
      initial_ECDH();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`, {
        method: "GET",
        headers: {
            'X-CSRFToken': csrf_token,
        }
    })
        .then(response => response.json())
        .then( async(data) => {
          for (const message of data.messages) {
                if (!(message.message_type=='erase chat'&&localStorage.getItem("USER"+peer_id.toString())==null)){
                  await displayMessage(message);
                }
                
                lastMessageId = message.message_id;
                console.log(message.message_type);
                var diff = Date.now()-new Date(message.created_at).getTime();
                var minutes = Math.floor((diff/1000)/60);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id && minutes<1  ){
                    if (localStorage.getItem("USER"+peer_id.toString())==null){
                      localStorage.setItem("USER"+peer_id.toString(),0);
                      localStorage.setItem("valid_since_USER"+peer_id.toString(),JSON.stringify(Date.now()));
                      localStorage.setItem("last_response_USER"+peer_id.toString(),0);
                      localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
                      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
                      localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
                      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
                      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
                      decryption_iv_me_to_peer = 0;
                      decryption_iv_peer_to_me = 0;
                      s_secret = 1;
                      c_keyset = 1;
                    }
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      reply_to_ECDH(message.message_text);
                     }
                    
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("last_response_USER"+peer_id.toString())==null){
                    localStorage.setItem("last_response_USER"+peer_id.toString(),0)
                  }
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      receive_ECDH_response(message.message_text);
                      
                    }
                }
                if (message.message_type=='refresh key' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("USER"+peer_id.toString())!=null){
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                      if (new Date(message.created_at).getTime()>last_res){
                        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                        reply_to_key_refresh(message);
                        
                      }
                  }
                }
                if (message.message_type == 'erase chat' && message.sender_id == peer_id){
                  if (localStorage.getItem("USER"+peer_id.toString())!=null){
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                        reply_to_erase_chat(message);
                        
                      }
                  }

                }
            };
        })
        .catch(error => console.error('Error fetching messages:', error));
    console.log("fetch message");
}

// Display a single message
async function displayMessage(message) {

    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');


    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    if (message.message_type=='normal' && localStorage.getItem("USER"+peer_id.toString())==null){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ERROR: local storage cleared"}`;
    }else if (message.message_type=="normal"){
      let text;
      last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
      if (last_res>=new Date(message.created_at).getTime() && older == true){
        text = await decryptolderMessage(message);
      }else {
        text = await decryptMessage(message);
        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
      }
      
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
    }else if (message.message_type=="refresh key reply"){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"Keys changed"}`;
    }
    else if (message.message_type=="refresh key"){
      messageElement.textContent = "==Keys changed==";
    }else if (message.message_type == "ECDH request" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH request"}`;
    }else if (message.message_type == "ECDH response" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH response"}`;
    }else if (message.message_type == "erase chat"){
      messageElement.textContent = "";
    }
    else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }

    messagesContainer.appendChild(messageElement);

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrf_token,
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });

    sendEraseChat();
}

async function reply_to_erase_chat(message){
  console.log('Receive erase chat request');

  if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
    if (localStorage.getItem("USER"+peer_id.toString())==null){
      localStorage.setItem("USER"+peer_id.toString(),0);
    localStorage.setItem("valid_since_USER"+peer_id.toString(),JSON.stringify(Date.now()));
    // localStorage.setItem("last_response_USER"+peer_id.toString(),0);
    localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
    // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
    localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
    localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
    localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);

    decryption_iv_me_to_peer = 0;
    decryption_iv_peer_to_me = 0;
    s_secret = 1;
    c_keyset = 1;
    }

}

async function reply_to_ECDH(otherpublickey){
  // if (myExportPublicKey == null){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log("shared secret key", keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log("encryption key", encryption);
    console.log("decryption key", decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log("mac key for me", mac_me);
    console.log("mac key for pair", mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log("shared secret key",keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    console.log("encryption key", encryption);
    console.log("decryption key", decryption);

    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    console.log("mac key for me", mac_me);
    console.log("mac key for pair", mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  ///////////////////////////////////////////////////////////////////////////

// generate shared secret after receiving other's public key
async function generate_secret_key(otherPublicKey){
    console.log("public key from peer", otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

// generate my secret/ public key pairs
async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log("my secret/public keypair", myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log("my exported public key", myExportPublicKey);
}


// derive the shared secret bits 
  async function deriveSharedSecret(privateKey, publicKey) {
    if (localStorage.getItem("secret_counter_USER"+peer_id.toString()) == null) {
      counter = 0;
    }else {
      counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    }
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}â¦[${secret.byteLength} bytes total]`;
    console.log("shared secret bits",content)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+(counter+1).toString(),str);
    localStorage.setItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+(counter+1).toString(),0);
    localStorage.setItem("secret_counter_USER"+peer_id.toString(),JSON.stringify(counter+1));
  }

  // from the shared secret bits get the shared secret key
  // the reason we convert bits-> keys is that bits are not extractable. To generate different key pairs
  // from the same shared secret, it is neccessary to store it. and the bits can be stored. So we derive 
  // bits and put it in the local storage. eveytime we need to derive new keypairs, we first convert the 
  // bits into the key, and then derive keypairs. 
  function get_shared_secret_key(){
    
    let counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+counter.toString()));
    
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}â¦[${secretfromstorage.byteLength} bytes total]`;
    console.log("shared secret bits from local storage"+content2);

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
async function refreshKeys() {
    console.log('Refresh keys');
    // Placeholder for refresh functionality
    await generate_edmac_key_user1();
    await sendRefreshKeyinit();
}

async function reply_to_key_refresh(message){
  console.log('Receive refresh keys request');
  result = await verifyOldMac(message, "change");
  if (result==false ){
    window.alert("invalid old mac");
    return;
  }
  result2 = await verifyNewMac(message, "change");
  if (result2 == false){
    window.alert("invalid new mac");
    return;
  }
  await generate_edmac_key_user2();
  // sendRefreshKeyreply()

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message, additional) {
    console.log("start encryption");
    console.log("plaintext",message);
    const encoded = await getMessageEncoding(message);
    console.log("encoded plaintext array buffer", getArrayBufferString(encoded));
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log("iv used to encrypt the message", count);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString(additional)},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    // let buffer = new Uint8Array(ciphertext, 0, 5);
    // console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("cyphertext value", getArrayBufferString(ciphertext));

    return getArrayBufferString(ciphertext);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
 // first == 0 
  async function decryptolderMessage(message) {
    console.log("decrypt older message");
    let valid_since = JSON.parse(localStorage.getItem("valid_since_USER"+peer_id.toString()));
    let last_iv;
    if (older ==true && localStorage.getItem("USER"+peer_id.toString())==null ){
      console.log("ERROR: local storage cleared")
      return "ERROR: local storage cleared";
    }

    if (valid_since>new Date(message.created_at).getTime()){
      console.log("ERROR: local storage cleared")
      return "ERROR: local storage cleared";
    }
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    if (message.sender_id == myID.toString()){
      last_iv = decryption_iv_me_to_peer;
    }else {
      last_iv = decryption_iv_peer_to_me;
    }

    m2p = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    p2m = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    c = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+s_secret.toString()));

      if (s_secret == secret_counter && c_keyset == counter && m2p == decryption_iv_me_to_peer && p2m == decryption_iv_peer_to_me){
          older=false;
          console.log("old messages finished.");
          return decryptMessage(message);
      }
      else if (c_keyset == c && m2p == decryption_iv_me_to_peer && decryption_iv_peer_to_me == p2m){
        s_secret = s_secret+1;
          c_keyset = 1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
      }else if (m2p == decryption_iv_me_to_peer && decryption_iv_peer_to_me == p2m) {
          c_keyset = c_keyset+1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
      }
    
      secret_counter_used = s_secret;
      counter_used = c_keyset;
      if (message.sender_id == myID.toString()){
        last_iv = decryption_iv_me_to_peer;
      }else {
        last_iv = decryption_iv_peer_to_me;
      }
      
    console.log("secret counter used to decrypt this old message",secret_counter_used);
    console.log("keyset counter used to decrypt this old message",counter_used);
    let valid = await verifyMessage(message, secret_counter_used, counter_used);
    if (!valid){
      // window.alert("signature invalid!")
      return "ERROR: signature invalid";
    }

    let ivnum = Number(message.message_iv);
    console.log("last iv VS this iv", last_iv, ivnum);
    if (last_iv>=ivnum){
        // window.alert("iv not valid");
        return "ERROR: invalid iv";
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter_used+"_SECRET"+secret_counter_used);
    const iv = await ivnumToUint8Array(ivnum);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log("ciphertext", getArrayBufferString(array_buffer));
    let decrypted;
    try{
      decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    }catch(error){
      console.error(error);
      return "ERROR: invalid decryption";
    }
      if (message.sender_id == myID.toString()){
        decryption_iv_me_to_peer = ivnum;
      }else {
        decryption_iv_peer_to_me = ivnum;
      }
    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log("decrypted message",decrypted_msg);
    return decrypted_msg;

  }
  async function decryptMessage(message) {
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    console.log("start decryption for new message");
    let valid = await verifyMessage(message, secret_counter, counter);
    if (!valid){
      console.log("signature invalid");
      return "signature invalid";
    }

    let last_iv;
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        console.log("ERROR: invalid iv");
        return "ERROR: invalid iv";
      }      
      localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    
    if (message.sender_id==peer_id.toString()){
      last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        console.log("ERROR: invalid iv");
        return "ERROR: invalid iv";
      }
      localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log("last iv VS this iv",last_iv, ivnum);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log("ciphertext", getArrayBufferString(array_buffer));
    
    let decrypted;
    try{
        decrypted = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: iv,
          additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
        },
        key,
        array_buffer
      );
    }catch(error){
      console.log(error);
      return "ERROR: invalid decryption";
    }

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log("decrypted message", decrypted_msg);
    return decrypted_msg;

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message, secret_counter, counter) {
    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);

    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );
    console.log("verifying signature:",result);

    return result;
  }

  async function verifyOldMac(message,str){
    const signatureValue = message.message_value;
    let signature_array = parseArrayBufferString(signatureValue);
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log("verifying old mac:",result);
    return result;
  }

  async function verifyNewMac(message,str){
    let keyMaterial =await get_shared_secret_key();
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());

    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+(count-1).toString()+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      mac_other,
      signature_array,
      encoded
    );

    console.log("verifying new mac:",result);
    return result;


  }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // get the shared secret bits from local storage and derive the keys
  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  // get the shared secret bits from local storage and derive the keys
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// the mac and iv of same secret
async function signiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:", signstr);
  return signstr;

}

async function signpreiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:",signstr);

  return signstr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}

function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}



</script>
</body>
</html>
