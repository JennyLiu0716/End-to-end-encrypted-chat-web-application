<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;
let myExportPublicKey_time;
let lastMessage;
let last_finished;

var decryption_iv_me_to_peer;
var decryption_iv_peer_to_me;
let s_secret;
let c_keyset;
let older;
// let first = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
    // myExportPublicKey == null;
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}
function sendRefreshKeyreply(){
  sendMessage("refresh key reply");
}
function sendEraseChat(){
  sendMessage("erase chat");
}

// Send message function
async function sendMessage(type) {
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let status = 'n';
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal' ) {
        secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
        counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
        
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='refresh key reply' ) {
      // secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      // counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
      message = "";
        // message0 = "Key changed";
        // message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());
        // message = message0;
        // iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        // tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
      secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signpreiv(counter, secret_counter,"change");
        // counter_previous = (counter).toString();
        // put the old mac signed iv into msg_value
        value = await signiv(counter-1, secret_counter, "change");
        counter = ""
        // iv = '';
    }
    if (type=='erase chat'){
      // secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      // counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
      //   iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
      //   tag = await signiv(Number(counter),Number(secret_counter),"");
      //   // counter_previous = (counter).toString();
      //   // put the old mac signed iv into msg_value
      //   // value = await signiv(counter-1, secret_counter, "erase");
      //   counter = ""
        // iv = '';
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
    };
    console.log("the message i sent");
    console.log(JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));

});

// Handle user selection change
document.getElementById('userList').addEventListener('change', async(event) => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    older = true;
    // first = 0;
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      decryption_iv_me_to_peer = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString()));
      decryption_iv_peer_to_me = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString()));
      s_secret = JSON.parse(localStorage.getItem("secret_START_USER"+peer_id.toString()));
      c_keyset = JSON.parse(localStorage.getItem("keyset_START_USER"+peer_id.toString()));
    }
    await fetchMessages(); // Fetch messages for the new selection
    // older = false;
    // first = 1;
    console.log("finish fetch");
    if (localStorage.getItem("USER"+peer_id.toString())==null && myID<peer_id){
      console.log("init becaus of ls");
      await initial_ECDH();
      // localStorage.setItem("USER"+peer_id.toString(),0);
      setInterval(fetchMessages, 1000);
      delay();
      // setTimeout(delay, 65000);
    }
    else if (localStorage.getItem("USER"+peer_id.toString())==null && myID>peer_id){
      // wait for 1 seconds to catch init if there is
      await new Promise(resolve => setTimeout(resolve, 1000));
      await fetchMessages();
      console.log("after this fetch");
      setInterval(fetchMessages, 1000);
      setInterval(checklocalStorage, 65000);
    }else {
      setInterval(fetchMessages, 1000);
      setInterval(checklocalStorage, 65000);

    }
    // setInterval(fetchMessages, 1000);
    
});

function delay(){
  // a key exchange message is valid for 1min
  setInterval(checklocalStorage, 65000);
}

function test(){
  console.log("hello");
}

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

function checklocalStorage(){
  console.log("checklocalStorage");
  if (localStorage.getItem("USER"+peer_id.toString())==null){
      initial_ECDH();
      // localStorage.setItem("USER"+peer_id.toString(),0);
    }
}

// async function asyncForEach(callback) {
//   await for(let i = 0; i < this.length; i++) {
//     await callback(this[i], i, this);
//   }
// }

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then( async(data) => {
          for (const message of data.messages) {
          //   await givePrizeToPlayer(player);
          // }
            // data.messages.asyncforEach(async(message) => {
                await displayMessage(message);
                console.log(message.created_at);
                lastMessageId = message.message_id;
                console.log(message.message_type);
                var diff = Date.now()-new Date(message.created_at).getTime();
                console.log(diff);
                var minutes = Math.floor((diff/1000)/60);
                console.log(minutes);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id && minutes<1  ){
                    if (localStorage.getItem("USER"+peer_id.toString())==null){
                      localStorage.setItem("USER"+peer_id.toString(),0);
                      localStorage.setItem("last_response_USER"+peer_id.toString(),0);
                      localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
                      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
                      localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
                      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
                      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
                      decryption_iv_me_to_peer = 0;
                      decryption_iv_peer_to_me = 0;
                      s_secret = 1;
                      c_keyset = 1;
                    }
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      reply_to_ECDH(message.message_text);
                     }
                    
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("last_response_USER"+peer_id.toString())==null){
                    localStorage.setItem("last_response_USER"+peer_id.toString(),0)
                  }
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      receive_ECDH_response(message.message_text);
                      
                    }
                }
                if (message.message_type=='refresh key' && message.sender_id == peer_id && minutes<1){
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      console.log((new Date(message.created_at).getTime()).toString())
                      reply_to_key_refresh(message);
                      
                    }
                }
                if (message.message_type == 'erase chat' && message.sender_id == peer_id){
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                  if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      console.log((new Date(message.created_at).getTime()).toString())
                      reply_to_erase_chat(message);
                      
                    }
                }
            };
        })
        .catch(error => console.error('Error fetching messages:', error));
    console.log("fetch message");
}

// Display a single message
async function displayMessage(message) {
  // try{
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    console.log("this");
    if (message.message_type=="normal"){
      console.log("sadd");
      let text;
      last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
      if (last_res>=new Date(message.created_at).getTime() && older == true){
        console.log("aaa");
        text = await decryptolderMessage(message);
      }else {
        text = await decryptMessage(message);
        console.log("bbb");
        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
      }
      
      // if (older == true){
      //   text = await decryptolderMessage(message);
      // }else {
      //   text = await decryptMessage(message);
      // }
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
      // console.log("message:",messageElement.textContent);
    }else if (message.message_type=="refresh key reply"){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"Keys changed"}`;
    }
    else if (message.message_type=="refresh key"){
      messageElement.textContent = "Keys changed";
    }else if (message.message_type == "ECDH request" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH request"}`;
    }else if (message.message_type == "ECDH response" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH response"}`;
    }else if (message.message_type == "erase chat"){
      messageElement.textContent = "";
    }
    else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }
    // messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    // console.log(messageElement.textContent);
    messagesContainer.appendChild(messageElement);
//   }catch(e) {
//     console.log(e.name, e.message);
// }
  // }
  


}

// console.log("already set interval");
// Periodically fetch new messages every second
// setInterval(fetchMessages, 1000);
// setInterval(checklocalStorage,2000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });

    sendEraseChat();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
    localStorage.setItem("USER"+peer_id.toString(),0);
    // localStorage.setItem("last_response_USER"+peer_id.toString(),0);
    localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
    // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
    localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
    localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
    localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
    
    decryption_iv_me_to_peer = 0;
    decryption_iv_peer_to_me = 0;
    s_secret = 1;
    c_keyset = 1;
}

async function reply_to_ECDH(otherpublickey){
  // if (myExportPublicKey == null){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();
    // myExportPublicKey == null;
  // }else {
  //   await generate_secret_key(otherpublickey);
  //   if (myID>peer_id){
  //     generate_edmac_key_user2();
  //   }else {
  //     await generate_edmac_key_user1();
  //   }
  //   myExportPublicKey ==null;
  // }



}

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log(encryption);
    console.log(decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log(mac_me);
    console.log(mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);

    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));
}

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

async function generate_secret_key(otherPublicKey){


    console.log(otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log(myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log(myExportPublicKey);
  // myExportPublicKey_time = 
}


  async function deriveSharedSecret(privateKey, publicKey) {
    if (localStorage.getItem("secret_counter_USER"+peer_id.toString()) == null) {
      counter = 0;
    }else {
      counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    }
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}â¦[${secret.byteLength} bytes total]`;
    console.log(content)
    // console.log(secret)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+(counter+1).toString(),str);
    localStorage.setItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+(counter+1).toString(),0);
    localStorage.setItem("secret_counter_USER"+peer_id.toString(),JSON.stringify(counter+1));
  }

  function get_shared_secret_key(){
    
    let counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+counter.toString()));
    
    // console.log(secretfromstorage);
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}â¦[${secretfromstorage.byteLength} bytes total]`;
    console.log(content2)

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
async function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
    await generate_edmac_key_user1();
    await sendRefreshKeyinit();
}

async function reply_to_key_refresh(message){
  console.log('Receive information to refresh keys');
  result = await verifyOldMac(message, "change");
  if (result==false ){
    window.alert("invalid old mac");
    return;
  }
  result2 = await verifyNewMac(message, "change");
  if (result2 == false){
    window.alert("invalid new mac");
    return;
  }
  await generate_edmac_key_user2();
  // sendRefreshKeyreply()

}

async function reply_to_erase_chat(message){
  console.log('Receive information to erase chat');
  // let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
  // let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));

  // result = await verifyMessage(message, secret_counter, counter );
  // if (result==false ){
  //   console.log("test");
  //   window.alert("ERROR: invalid mac in erase chat");
  //   return;
  // }
  // result2 = await verifyNewMac(message, "erase");
  // if (result2 == false){
  //   window.alert("invalid new mac");
  //   return;
  // }
  if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message, additional) {
    console.log(message);
    const encoded = await getMessageEncoding(message);
    console.log(getArrayBufferString(encoded));
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log(iv);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString(additional)},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let buffer = new Uint8Array(ciphertext, 0, 5);
    console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("type of ciphertect ",typeof ciphertext);
    console.log(getArrayBufferString(ciphertext));
    // console.log(typeof getArrayBufferString(ciphertext));
    return getArrayBufferString(ciphertext);

}

async function encrypt_changeKey_Message(message){

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
 // first == 0 
  async function decryptolderMessage(message) {
    console.log("older message");
    let last_iv;
    if (older ==true && localStorage.getItem("USER"+peer_id.toString())==null ){
      window.alert("local storage cleared");
      return "ERROR: local storage cleared";
    }
    // if (first == 0 && older == false){
    //   window.alert("CAN NOT DECRYPT");
    //   return "ERROR: can not decrypt";
    // }
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    if (message.sender_id == myID.toString()){
      last_iv = decryption_iv_me_to_peer;
    }else {
      last_iv = decryption_iv_peer_to_me;
    }
    console.log("keyset", c_keyset);
    console.log("secret",s_secret);
    m2p = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    p2m = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    console.log(p2m);
    console.log(m2p);
    console.log("decryption_iv_me_to_peer",decryption_iv_me_to_peer);
    console.log("decryption_iv_peer_to_me",decryption_iv_peer_to_me);
      if (s_secret == secret_counter && c_keyset == counter){
        if (m2p == decryption_iv_me_to_peer && p2m == decryption_iv_peer_to_me){
          older=false;
          console.log("old messages finished.");
          return decryptMessage(message);
        }
      }
      else if (s_secret == secret_counter){
        console.log(decryption_iv_me_to_peer);
        console.log(decryption_iv_peer_to_me);
        if (decryption_iv_me_to_peer == m2p && decryption_iv_peer_to_me == p2m){
          console.log("this enter");
          c_keyset = c_keyset+1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
        }
      }else {
        c = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+s_secret.toString()));
        if (decryption_iv_me_to_peer = m2p && decryption_iv_peer_to_me == p2m && c==c_keyset){
          s_secret = s_secret+1;
          c_keyset = 1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
        }
      }
    
      secret_counter_used = s_secret;
      counter_used = c_keyset;
      if (message.sender_id == myID.toString()){
        console.log("1",decryption_iv_me_to_peer);
        last_iv = decryption_iv_me_to_peer;
        console.log("2",decryption_iv_me_to_peer);
      }else {
        last_iv = decryption_iv_peer_to_me;
      }
      

    console.log("secret_counter_used",secret_counter_used);
    console.log("counter_used",counter_used);
    let valid = await verifyMessage(message, secret_counter_used, counter_used);
    if (!valid){
      window.alert("signature invalid!")
      return "ERROR: signature invalid";
    }

    let ivnum = Number(message.message_iv);
    if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter_used+"_SECRET"+secret_counter_used);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted;
    try{
      decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    }catch(error){
      console.error(error);
      window.alert("decryption invalid!");
      return "ERROR: invalid decryption";
    }


      if (message.sender_id == myID.toString()){
        console.log("3",decryption_iv_me_to_peer);
        decryption_iv_me_to_peer = ivnum;
        console.log("4",decryption_iv_me_to_peer);
      }else {
        decryption_iv_peer_to_me = ivnum;
      }
    
        

    console.log(decrypted);
    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    return decrypted_msg;

  }
  async function decryptMessage(message) {
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    console.log("start encryption");
    console.log(message.message_id);
    let valid = await verifyMessage(message, secret_counter, counter);
    if (!valid){
      window.alert("signature invalid!");
      console.log("signature invalid");
      return "signature invalid";
    }
    // let counter = message.message_secret_counter;
    // TODO
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
      }      
      localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    if (message.sender_id==peer_id.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        window.alert("iv not valid");
        return "ERROR: invalid iv";
      }
      localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    console.log(decrypted);

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    console.log("finish decryption");
    return decrypted_msg;

  }

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message, secret_counter, counter) {
    const signatureValue = message.message_tag;
    console.log(signatureValue);
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);
    // let counter = message.message_secret_counter;
    // TODO
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  async function verifyOldMac(message,str){
    const signatureValue = message.message_value;
    let signature_array = parseArrayBufferString(signatureValue);
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  async function verifyNewMac(message,str){
    let keyMaterial =await get_shared_secret_key();
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log(mac_other);

    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+(count-1).toString()+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      mac_other,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;


  }

  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  ////////////////////////////////////////////////////////////////////////////////////////////////////
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}




// the mac and iv of same secret
async function signiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;

}

async function signpreiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}


</script>
</body>
</html>
