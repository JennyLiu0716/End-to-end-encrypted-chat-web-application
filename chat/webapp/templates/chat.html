<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <div style="text-align: right"><a href="{{ url_for('rebind_otp') }}" style="text-align: right">Rebind OTP</a></div>
    <h2>Chat Application <small> - (<a href="{{ url_for('logout') }}">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <input type="hidden" name="csrf_token" value = "{{ csrf_token() }}" />
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <!-- <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button> -->
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;
let myExportPublicKey_time;
let lastMessage;
let last_finished;
var csrf_token = "{{ csrf_token() }}";


var decryption_iv_me_to_peer;
var decryption_iv_peer_to_me;
let s_secret;
let c_keyset;
let older;
// let first = 0;

$.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("X-CSRFToken", csrf_token);
            }
        }
    });

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
    // myExportPublicKey == null;
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}

function sendEraseChat(){
  sendMessage("erase chat");
}

// Send message function
async function sendMessage(type) {
  if (localStorage.getItem("USER"+peer_id.toString())==null && (type=='normal' || type=='refresh key')){
    window.alert("no key materials, please wait for seconds for ECDH exchange");
    return;
  }
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal' ) {
        secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
        counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
        
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0, "CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString());

        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signiv(Number(counter),Number(secret_counter),"");
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
      secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
      counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString())).toString();
      
        message = "";
        iv = (JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter.toString()))).toString();
        tag = await signpreiv(counter, secret_counter,"change");
        // put the old mac signed iv into msg_value
        value = await signiv(counter-1, secret_counter, "change");
    }
    if (type=='erase chat'){
        message = "";
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
    };
    console.log("the message I sent",JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrf_token,
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users', {
        method: "GET",
        headers: {
            'X-CSRFToken': csrf_token,
        }
    })
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));

});

// Handle user selection change
document.getElementById('userList').addEventListener('change', async(event) => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    older = true;
    // first = 0;
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      decryption_iv_me_to_peer = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString()));
      decryption_iv_peer_to_me = JSON.parse(localStorage.getItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString()));
      s_secret = JSON.parse(localStorage.getItem("secret_START_USER"+peer_id.toString()));
      c_keyset = JSON.parse(localStorage.getItem("keyset_START_USER"+peer_id.toString()));
    }
    await fetchMessages(); // Fetch messages for the new selection

    if (localStorage.getItem("USER"+peer_id.toString())==null && myID<peer_id){
      await initial_ECDH();
      setInterval(fetchMessages, 2000);
      delay();
    }
    else if (localStorage.getItem("USER"+peer_id.toString())==null && myID>peer_id){
      // wait for 2 seconds to catch init if there is
      await new Promise(resolve => setTimeout(resolve, 2000));
      await fetchMessages();
      setInterval(fetchMessages, 2000);
      setInterval(checklocalStorage, 65000);
    }else {
      setInterval(fetchMessages, 2000);
      setInterval(checklocalStorage, 65000);

    }
    // setInterval(fetchMessages, 1000);
    
});

function delay(){
  // a key exchange message is valid for 1min
  setInterval(checklocalStorage, 65000);
}

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

function checklocalStorage(){
  console.log("checklocalStorage");
  if (localStorage.getItem("USER"+peer_id.toString())==null){
      initial_ECDH();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`, {
        method: "GET",
        headers: {
            'X-CSRFToken': csrf_token,
        }
    })
        .then(response => response.json())
        .then( async(data) => {
          for (const message of data.messages) {
                if (!(message.message_type=='erase chat'&&localStorage.getItem("USER"+peer_id.toString())==null)){
                  await displayMessage(message);
                }
                
                lastMessageId = message.message_id;
                console.log(message.message_type);
                var diff = Date.now()-new Date(message.created_at).getTime();
                var minutes = Math.floor((diff/1000)/60);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id && minutes<1  ){
                    if (localStorage.getItem("USER"+peer_id.toString())==null){
                      localStorage.setItem("USER"+peer_id.toString(),0);
                      localStorage.setItem("valid_since_USER"+peer_id.toString(),JSON.stringify(Date.now()));
                      localStorage.setItem("last_response_USER"+peer_id.toString(),0);
                      localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
                      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
                      localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
                      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
                      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);
                      decryption_iv_me_to_peer = 0;
                      decryption_iv_peer_to_me = 0;
                      s_secret = 1;
                      c_keyset = 1;
                    }
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      reply_to_ECDH(message.message_text);
                     }
                    
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("last_response_USER"+peer_id.toString())==null){
                    localStorage.setItem("last_response_USER"+peer_id.toString(),0)
                  }
                  last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                      localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                      receive_ECDH_response(message.message_text);
                      
                    }
                }
                if (message.message_type=='refresh key' && message.sender_id == peer_id && minutes<1){
                  if (localStorage.getItem("USER"+peer_id.toString())!=null){
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                      if (new Date(message.created_at).getTime()>last_res){
                        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                        reply_to_key_refresh(message);
                        
                      }
                  }
                }
                if (message.message_type == 'erase chat' && message.sender_id == peer_id){
                  if (localStorage.getItem("USER"+peer_id.toString())!=null){
                    last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
                    if (new Date(message.created_at).getTime()>last_res){
                        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
                        reply_to_erase_chat(message);
                        
                      }
                  }

                }
            };
        })
        .catch(error => console.error('Error fetching messages:', error));
    console.log("fetch message");
}

// Display a single message
async function displayMessage(message) {

    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');


    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    if (message.message_type=='normal' && localStorage.getItem("USER"+peer_id.toString())==null){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ERROR: local storage cleared"}`;
    }else if (message.message_type=="normal"){
      let text;
      last_res = JSON.parse(localStorage.getItem("last_response_USER"+peer_id.toString()));
      if (last_res>=new Date(message.created_at).getTime() && older == true){
        text = await decryptolderMessage(message);
      }else {
        text = await decryptMessage(message);
        localStorage.setItem("last_response_USER"+peer_id.toString(),(new Date(message.created_at).getTime()).toString());
      }
      
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
    }else if (message.message_type=="refresh key reply"){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"Keys changed"}`;
    }
    else if (message.message_type=="refresh key"){
      messageElement.textContent = "==Keys changed==";
    }else if (message.message_type == "ECDH request" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH request"}`;
    }else if (message.message_type == "ECDH response" ){
      messageElement.textContent = `From ${sender} to ${receiver}: ${"ECDH response"}`;
    }else if (message.message_type == "erase chat"){
      messageElement.textContent = "";
    }
    else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }

    messagesContainer.appendChild(messageElement);

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing
    if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrf_token,
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });

    sendEraseChat();
}

async function reply_to_erase_chat(message){
  console.log('Receive erase chat request');

  if (localStorage.getItem("USER"+peer_id.toString())!=null){
      // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
      let s = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
      localStorage.setItem("secret_START_USER"+peer_id.toString(),JSON.stringify(s));
      let c = JSON.parse(localStorage.getItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("keyset_START_USER"+peer_id.toString(),JSON.stringify(c));
      let dmtp = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),JSON.stringify(dmtp));
      let dptm = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c.toString()+"_SECRET"+s.toString()));
      localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),JSON.stringify(dptm));
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
    if (localStorage.getItem("USER"+peer_id.toString())==null){
      localStorage.setItem("USER"+peer_id.toString(),0);
    localStorage.setItem("valid_since_USER"+peer_id.toString(),JSON.stringify(Date.now()));
    // localStorage.setItem("last_response_USER"+peer_id.toString(),0);
    localStorage.setItem("secret_START_USER"+peer_id.toString(),1);
    // localStorage.setItem("time_START_USER"+peer_id.toString(),0);
    localStorage.setItem("keyset_START_USER"+peer_id.toString(),1);
    localStorage.setItem("decryption_iv_START_USER"+myID.toString()+"to"+peer_id.toString(),0);
    localStorage.setItem("decryption_iv_START_USER"+peer_id.toString()+"to"+myID.toString(),0);

    decryption_iv_me_to_peer = 0;
    decryption_iv_peer_to_me = 0;
    s_secret = 1;
    c_keyset = 1;
    }

}

async function reply_to_ECDH(otherpublickey){
  // if (myExportPublicKey == null){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log("shared secret key", keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log("encryption key", encryption);
    console.log("decryption key", decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    console.log("mac key for me", mac_me);
    console.log("mac key for pair", mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log("shared secret key",keyMaterial);
    let secret_counter = JSON.parse(localStorage.getItem('secret_counter_USER'+peer_id.toString())).toString();
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;
    localStorage.setItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    console.log("encryption key", encryption);
    console.log("decryption key", decryption);

    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),decryption_str);
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);
    localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID.toString()+"to"+peer_id.toString());
    console.log("mac key for me", mac_me);
    console.log("mac key for pair", mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+count.toString()+"_SECRET"+secret_counter.toString(),JSON.stringify(mac_other_exported));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  ///////////////////////////////////////////////////////////////////////////

// generate shared secret after receiving other's public key
async function generate_secret_key(otherPublicKey){
    console.log("public key from peer", otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

// generate my secret/ public key pairs
async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log("my secret/public keypair", myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log("my exported public key", myExportPublicKey);
}


// derive the shared secret bits 
  async function deriveSharedSecret(privateKey, publicKey) {
    if (localStorage.getItem("secret_counter_USER"+peer_id.toString()) == null) {
      counter = 0;
    }else {
      counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    }
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}…[${secret.byteLength} bytes total]`;
    console.log("shared secret bits",content)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+(counter+1).toString(),str);
    localStorage.setItem("keyset_counter_USER"+peer_id.toString()+"_SECRET"+(counter+1).toString(),0);
    localStorage.setItem("secret_counter_USER"+peer_id.toString(),JSON.stringify(counter+1));
  }

  // from the shared secret bits get the shared secret key
  // the reason we convert bits-> keys is that bits are not extractable. To generate different key pairs
  // from the same shared secret, it is neccessary to store it. and the bits can be stored. So we derive 
  // bits and put it in the local storage. eveytime we need to derive new keypairs, we first convert the 
  // bits into the key, and then derive keypairs. 
  function get_shared_secret_key(){
    
    let counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_USER"+peer_id.toString()+"_COUNTER"+counter.toString()));
    
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}…[${secretfromstorage.byteLength} bytes total]`;
    console.log("shared secret bits from local storage"+content2);

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
async function refreshKeys() {
    console.log('Refresh keys');
    // Placeholder for refresh functionality
    await generate_edmac_key_user1();
    await sendRefreshKeyinit();
}

async function reply_to_key_refresh(message){
  console.log('Receive refresh keys request');
  result = await verifyOldMac(message, "change");
  if (result==false ){
    window.alert("invalid old mac");
    return;
  }
  result2 = await verifyNewMac(message, "change");
  if (result2 == false){
    window.alert("invalid new mac");
    return;
  }
  await generate_edmac_key_user2();
  // sendRefreshKeyreply()

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message, additional) {
    console.log("start encryption");
    console.log("plaintext",message);
    const encoded = await getMessageEncoding(message);
    console.log("encoded plaintext array buffer", getArrayBufferString(encoded));
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log("iv used to encrypt the message", count);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString(additional)},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString(), JSON.stringify(count));
    // let buffer = new Uint8Array(ciphertext, 0, 5);
    // console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("cyphertext value", getArrayBufferString(ciphertext));

    return getArrayBufferString(ciphertext);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
 // first == 0 
  async function decryptolderMessage(message) {
    console.log("decrypt older message");
    let valid_since = JSON.parse(localStorage.getItem("valid_since_USER"+peer_id.toString()));
    let last_iv;
    if (older ==true && localStorage.getItem("USER"+peer_id.toString())==null ){
      console.log("ERROR: local storage cleared")
      return "ERROR: local storage cleared";
    }

    if (valid_since>new Date(message.created_at).getTime()){
      console.log("ERROR: local storage cleared")
      return "ERROR: local storage cleared";
    }
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    if (message.sender_id == myID.toString()){
      last_iv = decryption_iv_me_to_peer;
    }else {
      last_iv = decryption_iv_peer_to_me;
    }

    m2p = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    p2m = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+c_keyset+"_SECRET"+s_secret));
    c = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+s_secret.toString()));

      if (s_secret == secret_counter && c_keyset == counter && m2p == decryption_iv_me_to_peer && p2m == decryption_iv_peer_to_me){
          older=false;
          console.log("old messages finished.");
          return decryptMessage(message);
      }
      else if (c_keyset == c && m2p == decryption_iv_me_to_peer && decryption_iv_peer_to_me == p2m){
        s_secret = s_secret+1;
          c_keyset = 1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
      }else if (m2p == decryption_iv_me_to_peer && decryption_iv_peer_to_me == p2m) {
          c_keyset = c_keyset+1;
          decryption_iv_me_to_peer = 0;
          decryption_iv_peer_to_me = 0;
      }
    
      secret_counter_used = s_secret;
      counter_used = c_keyset;
      if (message.sender_id == myID.toString()){
        last_iv = decryption_iv_me_to_peer;
      }else {
        last_iv = decryption_iv_peer_to_me;
      }
      
    console.log("secret counter used to decrypt this old message",secret_counter_used);
    console.log("keyset counter used to decrypt this old message",counter_used);
    let valid = await verifyMessage(message, secret_counter_used, counter_used);
    if (!valid){
      // window.alert("signature invalid!")
      return "ERROR: signature invalid";
    }

    let ivnum = Number(message.message_iv);
    console.log("last iv VS this iv", last_iv, ivnum);
    if (last_iv>=ivnum){
        // window.alert("iv not valid");
        return "ERROR: invalid iv";
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter_used+"_SECRET"+secret_counter_used);
    const iv = await ivnumToUint8Array(ivnum);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log("ciphertext", getArrayBufferString(array_buffer));
    let decrypted;
    try{
      decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    }catch(error){
      console.error(error);
      return "ERROR: invalid decryption";
    }
      if (message.sender_id == myID.toString()){
        decryption_iv_me_to_peer = ivnum;
      }else {
        decryption_iv_peer_to_me = ivnum;
      }
    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log("decrypted message",decrypted_msg);
    return decrypted_msg;

  }
  async function decryptMessage(message) {
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    console.log("start decryption for new message");
    let valid = await verifyMessage(message, secret_counter, counter);
    if (!valid){
      console.log("signature invalid");
      return "signature invalid";
    }

    let last_iv;
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        console.log("ERROR: invalid iv");
        return "ERROR: invalid iv";
      }      
      localStorage.setItem("decryption_iv_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    
    if (message.sender_id==peer_id.toString()){
      last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
      if (last_iv>=ivnum){
        console.log("ERROR: invalid iv");
        return "ERROR: invalid iv";
      }
      localStorage.setItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log("last iv VS this iv",last_iv, ivnum);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log("ciphertext", getArrayBufferString(array_buffer));
    
    let decrypted;
    try{
        decrypted = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: iv,
          additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
        },
        key,
        array_buffer
      );
    }catch(error){
      console.log(error);
      return "ERROR: invalid decryption";
    }

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log("decrypted message", decrypted_msg);
    return decrypted_msg;

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message, secret_counter, counter) {
    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);

    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );
    console.log("verifying signature:",result);

    return result;
  }

  async function verifyOldMac(message,str){
    const signatureValue = message.message_value;
    let signature_array = parseArrayBufferString(signatureValue);
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let counter = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()));
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_KEYSET"+counter+"_SECRET"+secret_counter);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log("verifying old mac:",result);
    return result;
  }

  async function verifyNewMac(message,str){
    let keyMaterial =await get_shared_secret_key();
    let secret_counter = JSON.parse(localStorage.getItem("secret_counter_USER"+peer_id.toString()));
    let count = JSON.parse(localStorage.getItem('keyset_counter_USER'+peer_id.toString()+"_SECRET"+secret_counter.toString()))+1;

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+peer_id.toString()+"to"+myID.toString());

    const signatureValue = message.message_tag;
    let signature_array = parseArrayBufferString(signatureValue);
    const last_iv = JSON.parse(localStorage.getItem("decryption_iv_USER"+peer_id.toString()+"to"+myID.toString()+"_KEYSET"+(count-1).toString()+"_SECRET"+secret_counter));
    const iv = await ivnumToUint8Array(last_iv);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str+str);
    let result = await window.crypto.subtle.verify(
      "HMAC",
      mac_other,
      signature_array,
      encoded
    );

    console.log("verifying new mac:",result);
    return result;


  }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // get the shared secret bits from local storage and derive the keys
  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  // get the shared secret bits from local storage and derive the keys
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// the mac and iv of same secret
async function signiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:", signstr);
  return signstr;

}

async function signpreiv(counter, secret_counter, additional){
  // let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_USER"+peer_id.toString()+"_KEYSET"+(counter-1).toString()+"_SECRET"+secret_counter));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str+additional);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_KEYSET"+counter.toString()+"_SECRET"+secret_counter);
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:",signstr);

  return signstr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}

function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}



</script>
</body>
</html>
