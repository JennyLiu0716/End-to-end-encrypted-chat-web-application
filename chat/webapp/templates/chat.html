<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
    <!-- <script type = "text/javascript" src="generateKeyPair.js"></script> -->
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendInputMessage()" class="btn btn-primary">Send</button>
            <button onclick="initial_ECDH()" class="btn btn-primary">generateKeyEC</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let myKeyPair;
let otherPublicKey;
let mySecretKey;
let myExportPublicKey;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function sendInputMessage(){
    sendMessage("normal");
}
function sendECDH_request(){
    sendMessage("ECDH request");
}
function sendECDH_response(){
    sendMessage("ECDH response");
}
function sendRefreshKeyinit(){
  sendMessage("refresh key");
}
function sendRefreshKeyreply(){
  sendMessage("refresh key");
}

// Send message function
async function sendMessage(type) {
    if (peer_id == -1) return; // Exit if no peer selected
    let message0,message;
    let status = 'n';
    let value = '';
    let tag = '';
    let iv = '';
    let counter = '';
    if (type=='normal') {
        counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString())).toString();
        message0 = document.getElementById('messageInput').value;
        message = await encryptMessage(message0);
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))).toString();
        tag = await signiv();
    }
    if (type=='ECDH request'||type=='ECDH response') {
        message0 = myExportPublicKey;
        message = message0;
    }
    if (type=='refresh key'){
        counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString())).toString();
        message0 = "Keys changed";
        message = await encrypt_changeKey_Message(message0);
        // message = message0;
        iv = (JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))).toString();
        tag = await signiv();
        // iv = '';
    }
    // const message = message0;
    const payload = {
        receiver_id: peer_id,
        message_text: message,
        message_type: type,
        message_iv: iv,
        message_value: value,
        message_tag: tag,
        message_secret_counter: counter,
    };
    console.log(JSON.stringify(payload));

    fetch('/send_message', {
        method: 'POST', // Specify the method
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        console.log('Message sent:', data); // Log success message
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}



// Populate users function
// document is the webpage. we define the id in the html. now we can get it
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(async(message) => {
                await displayMessage(message);
                lastMessageId = message.message_id;
                console.log(message.message_type);
                if (message.message_type == "ECDH request" && message.sender_id == peer_id){
                    reply_to_ECDH(message.message_text);
                }
                if (message.message_type=='ECDH response' && message.sender_id == peer_id){
                    receive_ECDH_response(message.message_text);
                }

            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
async function displayMessage(message) {
  // try{
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);
    console.log("this");
    if (message.message_type=="normal"){
      console.log("sadd");
      let text = await decryptMessage(message);
      messageElement.textContent = `From ${sender} to ${receiver}: ${text}`;
      // console.log("message:",messageElement.textContent);
    }else {
      messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    }
    // messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    // console.log(messageElement.textContent);
    messagesContainer.appendChild(messageElement);
//   }catch(e) {
//     console.log(e.name, e.message);
// }
  // }
  


}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function initial_ECDH(){
    await generateKey();
    sendECDH_request();
}

async function receive_ECDH_response(otherpublickey){
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user1();
}

async function reply_to_ECDH(otherpublickey){
    await generateKey();
    await sendECDH_response();
    await generate_secret_key(otherpublickey);
    await generate_edmac_key_user2();
}

async function generate_edmac_key_user1(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let count = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()))+1;
    localStorage.setItem('secret_bits_counter_'+peer_id.toString(), JSON.stringify(count));
    let encryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID+"to"+peer_id.toString());
    let decryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID);
    console.log(encryption);
    console.log(decryption);

    // buffer array
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),decryption_str);
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),0);

    let mac_me = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    let mac_other = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);
    
    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),JSON.stringify(mac_other_exported));


}

async function generate_edmac_key_user2(){
    let keyMaterial =await get_shared_secret_key();
    console.log(typeof keyMaterial);
    console.log(keyMaterial);
    let count = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()))+1;
    localStorage.setItem('secret_bits_counter_'+peer_id.toString(), JSON.stringify(count));
    let decryption = await getKey(keyMaterial, 2*count-1, "CHAT_KEY_"+myID.toString()+"to"+peer_id.toString());
    let encryption = await getKey(keyMaterial, 2*count, "CHAT_KEY_"+peer_id.toString()+"to"+myID.toString());
    
    const encryption_exported = await window.crypto.subtle.exportKey("raw",encryption);
    let encryption_str = getArrayBufferString(encryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),encryption_str);
    const decryption_exported = await window.crypto.subtle.exportKey("raw",decryption);
    let decryption_str = getArrayBufferString(decryption_exported);
    localStorage.setItem("CHAT_KEY_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),decryption_str);
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),0);
    localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),0);

    let mac_other = await getmacKey(keyMaterial, 2*count-1, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    let mac_me = await getmacKey(keyMaterial, 2*count, "CHAT_MAC_"+myID+"to"+peer_id.toString());
    console.log(mac_me);
    console.log(mac_other);

    mac_me_exported = await window.crypto.subtle.exportKey("jwk",mac_me);
    // console.log(typeof mac_me_exported);
    localStorage.setItem("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+count.toString(),JSON.stringify(mac_me_exported));
    mac_other_exported = await window.crypto.subtle.exportKey("jwk",mac_other);
    localStorage.setItem("CHAT_MAC_USER"+peer_id.toString()+"to"+myID.toString()+"_"+count.toString(),JSON.stringify(mac_other_exported));
}

  /*
  Given some key material and some random salt,
  derive an AES-GCM key using HKDF.
  */
  function getKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  }
  
  function getmacKey(keyMaterial, saltnum, information) {
    return window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: saltnumToUint8Array(saltnum),
        info: new Uint8Array(information),
        hash: "SHA-256",
      },
      keyMaterial,
      { name: "HMAC", 
        hash: "SHA-256",
        length: 256 },
      true,
      ["sign", "verify"]
    );
  }

  function saltnumToUint8Array(num) {
  let arr = new Uint8Array(16);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

function ivnumToUint8Array(num) {
  let arr = new Uint8Array(12);

  for (let i = 0; i < 16; i++) {
    arr[i] = num % 256;
    num = Math.floor(num / 256);
  }

  return arr;
}

async function generate_secret_key(otherPublicKey){
    console.log(otherPublicKey);
  const publicKey = await window.crypto.subtle.importKey(
    "jwk",
    JSON.parse(otherPublicKey.replaceAll("\'", "\"").replace("True","true")),
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    []
  );
    await deriveSharedSecret(
      myKeyPair.privateKey,
      publicKey
    );

}

async function generateKey() {
    myKeyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-384",
    },
    true,
    ["deriveBits","deriveBits"],
  );
  console.log(myKeyPair);
  myExportPublicKey = await window.crypto.subtle.exportKey(
    "jwk",
    myKeyPair.publicKey);
    console.log(myExportPublicKey);
}


  async function deriveSharedSecret(privateKey, publicKey) {
    const secret = await window.crypto.subtle.deriveBits(
        // NOT SURE 384
      { name: "ECDH", 
      public: publicKey },
      privateKey,
      384
    );
    const buffer = new Uint8Array(secret, 0, 48);
    content = `${buffer}â¦[${secret.byteLength} bytes total]`;
    console.log(content)
    // console.log(secret)
    let str = getArrayBufferString(secret);
    localStorage.setItem("secretbits_"+peer_id.toString(),str);
    localStorage.setItem("secret_bits_counter_"+peer_id.toString(),0);
  }

  function get_shared_secret_key(){
    let secretfromstorage = parseArrayBufferString(localStorage.getItem("secretbits_"+peer_id.toString()));
    // let strst = localStorage.getItem("secretbits");
    
    // console.log(secretfromstorage);
    const buffer2 = new Uint8Array(secretfromstorage,0,48);
    content2 = `${buffer2}â¦[${secretfromstorage.byteLength} bytes total]`;
    console.log(content2)

    return window.crypto.subtle.importKey(
      "raw",
      secretfromstorage,
      { name: "HKDF" },
      false,
      ["deriveKey"]
    );
  }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh Keys function placeholder
function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
    generate_edmac_key_user1();
    sendRefreshKeyinit();

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

async function encryptMessage(message) {
    console.log(message);
    const encoded = await getMessageEncoding(message);
    console.log(getArrayBufferString(encoded));
    let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+myID.toString()+"to"+peer_id.toString()+"_"+counter.toString());
    // iv will be needed for decryption
    let count = await JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()))+1;
    const iv = await ivnumToUint8Array(count);
    console.log(iv);
    ciphertext = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", 
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_MSG_USER"+myID.toString+"to"+peer_id.toString())},
        key,
        encoded,
    );
    // the cipher text is length of plain text + 16 bytes 
    localStorage.setItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString(), JSON.stringify(count));
    let buffer = new Uint8Array(ciphertext, 0, 5);
    console.log("cyphertext value "+ `${buffer}...[${ciphertext.byteLength} bytes total]`);
    console.log("type of ciphertect ",typeof ciphertext);
    console.log(getArrayBufferString(ciphertext));
    // console.log(typeof getArrayBufferString(ciphertext));
    return getArrayBufferString(ciphertext);

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /*
  Fetch the ciphertext and decrypt it.
  Write the decrypted message into the "Decrypted" box.
  */
 // sender side
  async function decryptMessage(message) {
    
    let valid = await verifyMessage(message);
    if (!valid){
      window.alert("signature invalid!")
      return "";
    }
    let counter = message.message_secret_counter;
    let ivnum = Number(message.message_iv);
    if (message.sender_id==myID.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+counter));
      if (last_iv>=ivnum){
        windows.alert("iv not valid");
      }
      localStorage.setItem("decryption_iv_"+myID.toString()+"to"+peer_id.toString()+"_"+counter, JSON.stringify(ivnum));
    }
    if (message.sender_id==peer_id.toString()){
      const last_iv = JSON.parse(localStorage.getItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+counter));
      if (last_iv>=ivnum){
        windows.alert("iv not valid");
      }
      localStorage.setItem("decryption_iv_"+peer_id.toString()+"to"+myID.toString()+"_"+counter, JSON.stringify(ivnum));
    }
    let key = await get_enc_dec_Key("CHAT_KEY_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_"+counter);
    const iv = await ivnumToUint8Array(ivnum);
    console.log(iv);
    let array_buffer = await parseArrayBufferString(message.message_text);
    console.log(getArrayBufferString(array_buffer));
    let decrypted = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: iv,
        additionalData: parseArrayBufferString("CHAT_KEY_USER"+myID.toString+"to"+peer_id.toString()),
      },
      key,
      array_buffer
    );
    console.log(decrypted);

    let dec = new TextDecoder();
    decrypted_msg= await dec.decode(decrypted);
    console.log(decrypted_msg);
    console.log(typeof decrypted_msg);
    return decrypted_msg;

  }

  /*
  Fetch the encoded message-to-sign and verify it against the stored signature.
  * If it checks out, set the "valid" class on the signature.
  * Otherwise set the "invalid" class.
  */
  async function verifyMessage(message) {
    const signatureValue = message.message_tag;
    console.log(signatureValue);
    let signature_array = parseArrayBufferString(signatureValue);
    let count = Number(message.message_iv);
    const iv = await ivnumToUint8Array(count);
    let iv_str = getArrayBufferString(iv);
    let encoded = getMessageEncoding(iv_str);
    let counter = message.message_secret_counter;
    let key = await get_mac("CHAT_MAC_USER"+message.sender_id.toString()+"to"+message.receiver_id.toString()+"_"+counter.toString());

    let result = await window.crypto.subtle.verify(
      "HMAC",
      key,
      signature_array,
      encoded
    );

    console.log(result);
    console.log(typeof result);
    return result;
  }

  function get_enc_dec_Key(name){
    let keystr = localStorage.getItem(name);
    let array_buffer = parseArrayBufferString(keystr);
    return window.crypto.subtle.importKey(
      "raw",
      array_buffer,
      { name: "AES-GCM" },
      false,
      ["encrypt","decrypt"]
    );
}

  ////////////////////////////////////////////////////////////////////////////////////////////////////
function get_mac(name){
  jwk = JSON.parse(localStorage.getItem(name));
  return window.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: "HMAC",
      hash: "SHA-256",
      length: 256
    },
    true,
    ["sign", "verify"],
  );

}




async function signiv(){
  let counter = JSON.parse(localStorage.getItem('secret_bits_counter_'+peer_id.toString()));
  let count = JSON.parse(localStorage.getItem("encryption_iv_"+peer_id.toString()+"_"+counter.toString()));
  const iv = await ivnumToUint8Array(count);
  let iv_str = getArrayBufferString(iv);
  let encoded = getMessageEncoding(iv_str);
  let key = await get_mac("CHAT_MAC_USER"+myID.toString()+"to"+peer_id.toString()+"_"+counter.toString());
  let signature = await window.crypto.subtle.sign("HMAC", key, encoded);
  let signstr = getArrayBufferString(signature);
  console.log("signature:")
  console.log(signstr);
  console.log(typeof signature);
  return signstr;
  

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function getMessageEncoding(message0) {
    const message = message0;
    const enc = new TextEncoder();
    return enc.encode(message);
    }

  function getArrayBufferString(arrayBuffer){
    return new Uint8Array(arrayBuffer).toString()
  }
  function parseArrayBufferString(string){
    return new Uint8Array(string.split(',')).buffer
  }

  function arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}


</script>
</body>
</html>
